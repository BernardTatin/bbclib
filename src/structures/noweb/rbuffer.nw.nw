\documentclass{scrartcl}

\input{common/prelude.tex}

\author{Bernard Tatin}
\date{2013/2017}
\title{rbuffer.h, un buffer tournant}
\begin{document}

\pagestyle{noweb}
\maketitle
\abstract{Voici un premier essai de \emph{literate programming}, concept inventé par D. Knuth il y a plus de trente ans. À partir de ce seul fichier on génère la documentation et le code. Ici, je reprend du vieux code, cela m'oblige, même s'il est simple, à le repenser et donc, espérons le, à l'améliorer. Même si je passe beaucoup de temps sur la présentation...

Ce code est très orienté \emph{ligne de caractères} et a servi, entre autre, à la gestion de modems sur des systèmes embarqués. On notera l'absence de gestion de trop plein du buffer, \emph{i.e.} de l'écrasement de caractères lors du remplissage. Certains systèmes embarqués m'en ont découragés par manque de mémoire et une commande de modem écrasée était une commande modem mal formée... Jeu dangereux qui a finalement bien fonctionné.}

\tableofcontents
\section{rbuffer}

C'est un buffer tournant le plus simple possible, capable de gérer des lignes délimitées par \emph{LF} (\texttt{'$\backslash$n'}) mais \emph{CR} (\texttt{'$\backslash$r'}) n'est pas pris en compte, plus exactement, il est rejetté.

\subsection{premières définitions}
Pour limiter les calculs, le code..., la taille du buffer est une puissance de 2 d'où la définition du nombre de bits qui ouvre le bal, et en tenant compte du fait que cette définition peut-être donnée en paramètre du préprocesseur :

<<intro-bits>>=
# if !defined(_RBUFFER_BITS)
#define _RBUFFER_BITS   8
#endif
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

La taille du buffer sera donc :

<<intro-bits>>=
#define RBUFFER_SIZE    (1 << _RBUFFER_BITS)
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
Et le masque permettant un rapidide \emph{modulo} arithmétique avec un [[and]] binaire :
<<intro-bits>>=
#define RBUFFER_MASK    (RBUFFER_SIZE - 1)

@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\subsection{la structure}

\textbf{\textit{Note: }} tous les membres de la structure sont définis comme [[volatile]]. C'est important dans un système embarqué avec des interruptions pouvant manipuler le buffer. Sans [[volatile]], une optimisation trop agressive pourrait placer une des valeurs entières dans un registre. En cas d'interruption modifiant cette valeur, le registre, lui, ne bougera pas et des caractères pourraient se perdre.

<<tsrbuffer>>=
/**
 * @struct TSrbuffer
 * La structure gérant le buffer tournant.
 */
typedef struct {
    volatile int in;
    volatile int out;
    volatile int line_count;
    volatile char buffer[RBUFFER_SIZE];
} TSrbuffer;

@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\subsubsection{les champs}
\subsubsection{remarques diverses}
On pourrait définir un [[VOLATILE]] en fonction de l'architecture du type :

<<define-volatile>>=
#if defined(__with_irqs)
  #define VOLATILE volatile
#else
  #define VOLATILE
#endif

@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
Ce qui donnerait au final :

<<tsrbuffer-final>>=
/**
 * @struct TSrbuffer
 * La structure gérant le buffer tournant.
 */
typedef struct {
    VOLATILE int in;
    VOLATILE int out;
    VOLATILE int line_count;
    VOLATILE char buffer[RBUFFER_SIZE];
} TSrbuffer;

@ %def TSrbuffer
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
Quoiqu'il en soit, il est fortement recommandé de lire la définition exacte du [[VOLATILE]] de votre compilateur, certaines variations pouvant rendre votre code totalement inefficace. Et d'autant plus que votre compilateur cible un système embarqué où les variations autour des standards sont choses communes.
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}


\subsection{le fonctionnement}
\subsubsection{ajout d'un caractère}
Le fonctionnement est le suivant pour l'ajout d'un caractère :

\begin{packed_itemize}
  \item si le caractère est '$\backslash$r', on ne fait rien,
  \item on place le caractère dans le buffer à la position [[in]],
  \item on incrémente [[in]],
  \item si on atteint la limite du buffer, on positionne [[in]] à 0,
  \item si le caractère est '$\backslash$n', on incrémente [[line_count]].
\end{packed_itemize}

<<add-char>>=
static INLINE void rbf_add_char(TSrbuffer *rb, const char c) {
    if (c != '\r') {
        rb->buffer[rb->in++] = c;
        rb->in &= RBUFFER_MASK;
        if (c == '\n') {
            rb->line_count++;
        }
    }
}
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
La récupération d'un caractère dans le buffer est l'algorithme inverse :

<<get-char>>=
static INLINE char rbf_get_char(TSrbuffer *rb) {
    int out = rb->out;
    char c = rb->buffer[out++];
    out &= RBUFFER_MASK;
    rb->out = out;
    if (c == '\n' && rb->line_count) {
        rb->line_count--;
    }
    return c;
}
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

Il est cependant très important de déterminer si des caratères sont présents dans le buffer :
<<has-chars>>=
static INLINE bool rbf_has_chars(TSrbuffer *rb) {
    return rb->in != rb->out;
}
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

Le marquage d'une fin de ligne se fait par un '$backslash$0' :
<<end-of-line>>=

static INLINE void rbf_end_of_line(TSrbuffer *rb) {
    rb->buffer[rb->in] = 0;
    rb->line_count++;
}

@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
Ces fonctions, nécessitant une boucle, ne sont pas déclarées [[INLINE]] :
<<more-functions-h>>=
void rbf_add_line(TSrbuffer *rb, char *line);
int rbf_get_line(TSrbuffer *rb, char *line);
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

L'ajout d'une ligne est \emph{simple} :
<<more-functions-c>>=
void rbf_add_line(TSrbuffer *rb, char *line) {
    char c;

    while ((c = *(line++)) != 0) {
        rbf_add_char(rb, c);
    }
    rbf_end_of_line(rb);
}
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}

Et la lecture d'une ligne :
<<more-functions-c>>=
int rbf_get_line(TSrbuffer *rb, char *line) {
    char c;
    int r = 0;

    while (rbf_has_chars(rb)) {
        c = rbf_get_char(rb);

        if (c == '\n') {
            break;
        }
        if (c != 0) {
            *(line++) = c;
        }
        r++;
    }
    *line = 0;
    return r;
}
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}



\subsection{le code final}
\subsubsection{[[rbuffer.h]]}
<<rbuffer.nw.h>>=
/*
 * rbuffer.h
 * generated by noweb
 */

#if !defined(__rbuffer_h__)
#define __rbuffer_h__

<<intro-bits>>

<<define-volatile>>

<<tsrbuffer-final>>

<<add-char>>

<<get-char>>

<<has-chars>>

<<more-functions-h>>

#endif // __rbuffer_h__
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\subsubsection{[[rbuffer.c]]}
<<rbuffer.nw.c>>=
/*
 * rbuffer.c
 * generated by noweb
 */

#include "rbuffer.h"

<<more-functions-c>>
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
\section{annexes}

\subsection{la ligne de commande}
Pour obtenir le fichier \LaTeX{} et le code source, voici ce qu'il faut faire depuis un terminal :

<<command-line>>=
# fichier LaTeX
noweave -delay -autodefs c -index rbuffer.nw > rbuffer.tex
# fichier PDF
pdflatex rbuffer.tex && \
  pdflatex rbuffer.tex && \
  pdflatex rbuffer.tex
# le code source
notangle rbuffer.nw > rbuffer.h
@
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
L'option [[-autodefs c]] permet à [[noweave]] de déterminer lui-même les éléments du langage C. Sans cette option, dans le cadre de ce fichier, les définitions de [[intro-bits]] ne seraient pas visibles.

\section{tables et index}
\subsection{table des extraits de code}

\nowebchunks

\subsection{index}

\nowebindex

\end{document}
\documentclass{scrartcl}

\input{common/prelude.tex}

\author{Bernard Tatin}
\date{2013/2017}
\title{rbuffer.h, un buffer tournant}
\begin{document}

\pagestyle{noweb}
\maketitle
\abstract{Voici un premier essai de \emph{literate programming}, concept inventé par D. Knuth il y a plus de trente ans. À partir de ce seul fichier on génère la documentation et le code. Ici, je reprend du vieux code, cela m'oblige, même s'il est simple, à le repenser et donc, espérons le, à l'améliorer. Même si je passe beaucoup de temps sur la présentation...

Ce code est très orienté \emph{ligne de caractères} et a servi, entre autre, à la gestion de modems sur des systèmes embarqués. On notera l'absence de gestion de trop plein du buffer, \emph{i.e.} de l'écrasement de caractères lors du remplissage. Certains systèmes embarqués m'en ont découragés par manque de mémoire et une commande de modem écrasée était une commande modem mal formée... Jeu dangereux qui a finalement bien fonctionné.}

\tableofcontents
\section{rbuffer}

C'est un buffer tournant le plus simple possible, capable de gérer des lignes délimitées par \emph{LF} (\texttt{'$\backslash$n'}) mais \emph{CR} (\texttt{'$\backslash$r'}) n'est pas pris en compte, plus exactement, il est rejetté.

\subsection{premières définitions}
Pour limiter les calculs, le code..., la taille du buffer est une puissance de 2 d'où la définition du nombre de bits qui ouvre le bal, et en tenant compte du fait que cette définition peut-être donnée en paramètre du préprocesseur :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<intro-bits>>=
# if !defined(_RBUFFER_BITS)
#define _RBUFFER_BITS   8
#endif
@

La taille du buffer sera donc :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<intro-bits>>=
#define RBUFFER_SIZE    (1 << _RBUFFER_BITS)
@
Et le masque permettant un rapidide \emph{modulo} arithmétique avec un [[and]] binaire :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<intro-bits>>=
#define RBUFFER_MASK    (RBUFFER_SIZE - 1)

@
\subsection{la structure}

\textbf{\textit{Note: }} tous les membres de la structure sont définis comme [[volatile]]. C'est important dans un système embarqué avec des interruptions pouvant manipuler le buffer. Sans [[volatile]], une optimisation trop agressive pourrait placer une des valeurs entières dans un registre. En cas d'interruption modifiant cette valeur, le registre, lui, ne bougera pas et des caractères pourraient se perdre.

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<tsrbuffer>>=
/**
 * @struct TSrbuffer
 * La structure gérant le buffer tournant.
 */
typedef struct {
    volatile int in;
    volatile int out;
    volatile int line_count;
    volatile char buffer[RBUFFER_SIZE];
} TSrbuffer;

@
\subsubsection{les champs}
\subsubsection{remarques diverses}
On pourrait définir un [[VOLATILE]] en fonction de l'architecture du type :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<define-volatile>>=
#if defined(__with_irqs)
  #define VOLATILE volatile
#else
  #define VOLATILE
#endif

@
Ce qui donnerait au final :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<tsrbuffer-final>>=
/**
 * @struct TSrbuffer
 * La structure gérant le buffer tournant.
 */
typedef struct {
    VOLATILE int in;
    VOLATILE int out;
    VOLATILE int line_count;
    VOLATILE char buffer[RBUFFER_SIZE];
} TSrbuffer;

@ %def TSrbuffer
Quoiqu'il en soit, il est fortement recommandé de lire la définition exacte du [[VOLATILE]] de votre compilateur, certaines variations pouvant rendre votre code totalement inefficace. Et d'autant plus que votre compilateur cible un système embarqué où les variations autour des standards sont choses communes.
@


\subsection{le fonctionnement}
\subsubsection{ajout d'un caractère}
Le fonctionnement est le suivant pour l'ajout d'un caractère :

\begin{packed_itemize}
  \item si le caractère est '$\backslash$r', on ne fait rien,
  \item on place le caractère dans le buffer à la position [[in]],
  \item on incrémente [[in]],
  \item si on atteint la limite du buffer, on positionne [[in]] à 0,
  \item si le caractère est '$\backslash$n', on incrémente [[line_count]].
\end{packed_itemize}

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<add-char>>=
static INLINE void rbf_add_char(TSrbuffer *rb, const char c) {
    if (c != '\r') {
        rb->buffer[rb->in++] = c;
        rb->in &= RBUFFER_MASK;
        if (c == '\n') {
            rb->line_count++;
        }
    }
}
@
La récupération d'un caractère dans le buffer est l'algorithme inverse :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<get-char>>=
static INLINE char rbf_get_char(TSrbuffer *rb) {
    int out = rb->out;
    char c = rb->buffer[out++];
    out &= RBUFFER_MASK;
    rb->out = out;
    if (c == '\n' && rb->line_count) {
        rb->line_count--;
    }
    return c;
}
@

Il est cependant très important de déterminer si des caratères sont présents dans le buffer :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<has-chars>>=
static INLINE bool rbf_has_chars(TSrbuffer *rb) {
    return rb->in != rb->out;
}
@

Le marquage d'une fin de ligne se fait par un '$backslash$0' :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<end-of-line>>=

static INLINE void rbf_end_of_line(TSrbuffer *rb) {
    rb->buffer[rb->in] = 0;
    rb->line_count++;
}

@
Ces fonctions, nécessitant une boucle, ne sont pas déclarées [[INLINE]] :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<more-functions-h>>=
void rbf_add_line(TSrbuffer *rb, char *line);
int rbf_get_line(TSrbuffer *rb, char *line);
@

L'ajout d'une ligne est \emph{simple} :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<more-functions-c>>=
void rbf_add_line(TSrbuffer *rb, char *line) {
    char c;

    while ((c = *(line++)) != 0) {
        rbf_add_char(rb, c);
    }
    rbf_end_of_line(rb);
}
@

Et la lecture d'une ligne :
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<more-functions-c>>=
int rbf_get_line(TSrbuffer *rb, char *line) {
    char c;
    int r = 0;

    while (rbf_has_chars(rb)) {
        c = rbf_get_char(rb);

        if (c == '\n') {
            break;
        }
        if (c != 0) {
            *(line++) = c;
        }
        r++;
    }
    *line = 0;
    return r;
}
@



\subsection{le code final}
\subsubsection{[[rbuffer.h]]}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<rbuffer.nw.h>>=
/*
 * rbuffer.h
 * generated by noweb
 */

#if !defined(__rbuffer_h__)
#define __rbuffer_h__

<<intro-bits>>

<<define-volatile>>

<<tsrbuffer-final>>

<<add-char>>

<<get-char>>

<<has-chars>>

<<more-functions-h>>

#endif // __rbuffer_h__
@
\subsubsection{[[rbuffer.c]]}
\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<rbuffer.nw.c>>=
/*
 * rbuffer.c
 * generated by noweb
 */

#include "rbuffer.h"

<<more-functions-c>>
@
\section{annexes}

\subsection{la ligne de commande}
Pour obtenir le fichier \LaTeX{} et le code source, voici ce qu'il faut faire depuis un terminal :

\noindent\makebox[\linewidth]{\rule{\paperwidth}{0.4pt}}
<<command-line>>=
# fichier LaTeX
noweave -delay -autodefs c -index rbuffer.nw > rbuffer.tex
# fichier PDF
pdflatex rbuffer.tex && \
  pdflatex rbuffer.tex && \
  pdflatex rbuffer.tex
# le code source
notangle rbuffer.nw > rbuffer.h
@
L'option [[-autodefs c]] permet à [[noweave]] de déterminer lui-même les éléments du langage C. Sans cette option, dans le cadre de ce fichier, les définitions de [[intro-bits]] ne seraient pas visibles.

\section{tables et index}
\subsection{table des extraits de code}

\nowebchunks

\subsection{index}

\nowebindex

\end{document}
