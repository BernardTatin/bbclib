\documentclass[10pt]{article}
\usepackage{noweb}
\noweboptions{smallcode,longchunks}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% \usepackage[french]{babel}

\author{Bernard Tatin}
\date{2013/2017}
\title{rbuffer.h, un buffer tournant}


\begin{document}
\pagestyle{noweb}
\maketitle
\tableofcontents
\section{rbuffer}

C'est un [[buffer tournant]] le plus simple possible, capable de gérer des lignes
délimitées par \emph{LF} (\texttt{'$\backslash$n'}) mais \emph{CR} (\texttt{'$\backslash$r'}) n'est pas pris en compte.

\subsection{premières définitions}
Pour limiter les calculs, le code..., la taille du buffer est une puissance de 2
d'où la définition du nombre de bits qui ouvre le bal :

<<intro-bits>>=
#define _RBUFFER_BITS   8
#define RBUFFER_SIZE    (1 << _RBUFFER_BITS)
#define RBUFFER_MASK    (RBUFFER_SIZE - 1)
@ %def _RBUFFER_BITS RBUFFER_SIZE RBUFFER_MASK

@
\subsection{la structure}

On note que tous les membres de la structure sont définis comme [[volatile]]. C'est important dans un système embarqué avec des interruptions pouvant manipuler le buffer, cela empêche des boucles d'être optimisées au point de ne plus lire la valeur contenue dans la structure pour la stocker dans un registre.

<<tsrbuffer>>=
/**
 * @struct TSrbuffer
 * La structure gérant le buffer tournant.
 */
typedef struct {
    volatile int in; /**< index du caractère à ajouter */
    volatile int out; /**< index du caractère à sortir */
    volatile int line_count; /**< nombre de lignes contenues dans le tampon */
    volatile char buffer[RBUFFER_SIZE]; /**< le tampon */
} TSrbuffer;
@ %def TSrbuffer

\subsection{le code final}

<<*>>=
<<intro-bits>>
<<tsrbuffer>>

@
\paragraph{Defined Chunks}\par\noindent

\nowebchunks

\paragraph{Index}\par\noindent

\nowebindex

\end{document}
